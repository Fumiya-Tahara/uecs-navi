// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: time_schedule_rows.sql

package mysqlc

import (
	"context"
	"time"
)

const createTimeScheduleRow = `-- name: CreateTimeScheduleRow :execlastid
INSERT INTO time_schedule_rows (time_schedule_id, start_time, end_time, workflow_id)
VALUES (?, ?, ?, ?)
`

type CreateTimeScheduleRowParams struct {
	TimeScheduleID int32
	StartTime      time.Time
	EndTime        time.Time
	WorkflowID     int32
}

func (q *Queries) CreateTimeScheduleRow(ctx context.Context, arg CreateTimeScheduleRowParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createTimeScheduleRow,
		arg.TimeScheduleID,
		arg.StartTime,
		arg.EndTime,
		arg.WorkflowID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const getTimeScheduleRowsFromTimeSchedule = `-- name: GetTimeScheduleRowsFromTimeSchedule :many
SELECT id, time_schedule_id, start_time, end_time, workflow_id
FROM time_schedule_rows
WHERE time_schedule_id = ?
`

type GetTimeScheduleRowsFromTimeScheduleRow struct {
	ID             int32
	TimeScheduleID int32
	StartTime      time.Time
	EndTime        time.Time
	WorkflowID     int32
}

func (q *Queries) GetTimeScheduleRowsFromTimeSchedule(ctx context.Context, timeScheduleID int32) ([]GetTimeScheduleRowsFromTimeScheduleRow, error) {
	rows, err := q.db.QueryContext(ctx, getTimeScheduleRowsFromTimeSchedule, timeScheduleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTimeScheduleRowsFromTimeScheduleRow
	for rows.Next() {
		var i GetTimeScheduleRowsFromTimeScheduleRow
		if err := rows.Scan(
			&i.ID,
			&i.TimeScheduleID,
			&i.StartTime,
			&i.EndTime,
			&i.WorkflowID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
